## 进阶编程

### 1. 模板

泛型编程，提供函数模板和类模板
*学习模板的目的*: 为了后续学习使用STL提供的模板

#### 1.1 [函数模板](../part3/template/function/template_function.cpp)

作用: 建立一个通用函数，其函数返回值类型和形参可以不具体指定，用一个虚拟的类型代表

语法:
```
template<tyname T>
函数声明或者定义
```
解释:

* template 声明创建模板
* typename 数据类型，也可以用`class`代替
* T        常用的一种数据类型，名称可以替换，通常为大写字母

使用注意事项:
* 自动类型推导，必须推导出一致的数据类型T，才可以使用
* 模板必须要确定出T的数据类型，才可以使用


*普通函数与函数模板的区别:*
* 普通函数调用是可以发生自动类型转换
* 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
* 如果利用显示指定类型的方式，可以发生隐式类型转换


*普通函数与函数模板的调用规则:*
* 如果普通函数和模板函数都可以调用，优先调用普通函数
* 通过空参数列表，可以强制调用模板函数
* 通过函数重载，调用模板函数、
* 通过函数模板产生更好的匹配，优先调用函数模板

*函数模板的局限性:*
`T`为数组或者自定义数据类型时，模板函数就显得有点笨重

1、重载可以解决
2、利用具体化的模板，可以解决自定义类型的通用化
[示例](../part3/template/function/template_function_example.cpp)


#### 1.2 [类模板](../part3/template/class/template_class.cpp)

作用: 建立一个通用类，类汇总的成员，数据类型可以不具体制定，用一个虚拟的类型来代表

语法:
```
template<typename T>
class classname
```

解释:

* template 声明创建模板
* typename 数据类型，也可以用`class`代替
* T        常用的一种数据类型，名称可以替换，通常为大写字母
 

*类模板和函数模板的区别:*

* 类模板没有自动类型推导的使用方式
* 类模板在模板参数列表中可以使用默认参数


##### 1.2.1 [类模板中成员函数的创建时机](../part3/template/class/template_class_member_func.cpp)

##### 1.2.2 [类模板对象作函数参数](../part3/template/class/template_class_as_func_args.cpp)

* 1. 传入指定类型  (推荐使用，告诉编译器传入类型)
* 2. 参数模板化
* 3. 整个类模板化


##### 1.2.3 [类模板与继承](../part3/template/class/template_class_inherit.cpp)

当类模板发生继承时，需要主要一下几点:
* 当子类继承父类模板时，子类在声明的时候，要指定父类的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定父类T 的类型，子类也需要变为类模板

##### 1.2.4 [类模板成员函数类外实现](../part3/template/class/template_class_memeber_func_real_out_of_class.cpp)

模板类构造函数、成员函数实现: 类内声明，类外实现；需要加上模板参数列表


##### 1.2.5 [类模板分文件编写](../part3/template/class/demo/)

问题: 类模板中成员函数的创建时机是在调用阶段，导致分文件编写时链接不到

解决: 
* 方式1: 直接包含*.cpp源文件
* 方式2: 将声明和实现写到一个文件中，并更改后缀为*.hpp


##### 1.2.6 [类模板和友元函数](../part3/template/class/template_class_friend.cpp)

全局函数类内实现: 直接在类内声明友元即可（推荐使用）

全局函数类外实现: 需要提前让编译器知道全局函数的存在

##### 1.2.7 [类模板案例--数组封装](../part3/template/class/example/)

其功能类似于vector
完成:

    数组 容量 大小

    构造函数，拷贝构造函数 重载operate= 

    利用下标访问数组中的元素 尾部添加元素 尾部删除元素

    获取数组容量 获取数组大小

    析构函数