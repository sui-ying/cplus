## 核心编程

### 1. 内存分区模型

C++程序在执行时，将内存大方向分为4个区域:

* 代码区:存放函数的二进制代码，由操作系统进行管理的

* 全局区:存放全局变量、静态变量和常量

* 栈区:由编译器自动分配释放，存放函数的参数值，全局变量等

* 堆区:由程序员分配new和释放delete，若不释放，程序结束时有操作系统回收；由关键字new创建

内存分区意义: 不同区域存放的数量，赋予不同的生命周期，更加灵活地编程


#### 1.1 程序运行前

代码区:

* 存放CPU执行的机器指令
* 代码区是共享的，共享的母的是杜宇频繁被执行的程序，只需要在内存中有一封代码即可
* 代码区是只读的，使其只读的原因是防止程序意外的修改它的指令

全局区:

* 全局变量和惊天变量存放在此
* 全局区还包含了常量区，字符串常量和其他常量
* 该区域的数据在程序执行后由操作系统释放


#### 1.2 程序运行后

栈区:
* 栈区的数据有编译器管理和开辟、释放
* 不要返回局部变量的地址


### 2. 引用

* 作用: 给变量起别名
* 引用必须初始化，之后不可以改变


### 3. 函数进阶

* 函数默认参数
* 函数重载


### 4. 类和对象

C++面向对象的三大特性为: *封装*、*继承*、*多态*

    encapsulation inherits polymorphism

对象有其属性(成员变量)和行为(成员函数)


#### 4.1 封装

##### 4.1.1 封装的意义

* 将属性和行为作为一个整体，表现生活中的事务
* 将属性和行为加以权限控制

1. 在设计类的时候，将属性和行为写在一起，表现事物

语法: `class classname {};`

2. 访问权限

*公共权限 pubic       成员 类内可以访问，类外也可以访问
*保护权限 protected   成员 类内可以访问，类外不可以访问
*私有权限 private     成员 类内可以访问，类外不可以访问

保护权限和私有权限，在类的[继承](#### 4.6) 时有所不同

一般做法: 将成员属性设置为私有，对于写可以检测数据的有效性


#### 4.2 对象的初始化和清理 

##### 4.2.1 *构造函数和析构函数*

对象的初始化和清理是非常重要的安全问题:
* 一个对象或者变量没有初始状态，对其使用后果是未知的
* 同样的使用完一个对象或者变量 没有及时清理，也会造成一定的安全问题(比如内存泄露)

C++通过使用构造函数和析构函数解决上述问题，将这两个函数会被编译器自动调用，完成对象初始化和清理工作
如果编写代码中不提供构造和析构，编译器会提供
编译器提供的构造韩函数析构函数是空实现的

*构造函数*: 主要作用于创建对象时为对象的成员属性赋值，构造函数有编译器自动调用，无须手动调用
*析构函数*: 主要作用于对象销毁前系统自动调用，执行一些清理工作

[构造函数]语法: `类名(){}`
1. 构造函数没有返回值也不写void
2. 函数名称与，类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次

[析构函数]语法: `~类名(){}`
1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数*不可以有参数*，因此不可以重载
4. 程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次


##### 4.2.2 *构造函数和析构函数*的分类和调用

两种分类方式:
* 按参数分为: 有参构造和无惨构造
* 按类型分为: 普通构造和拷贝构造

三种调用方式:
1. 括号法
2. 显示法
3. 隐式转换法

拷贝构造函数的使用时机:
1. 使用一个已经创建完毕的对象 来初始化
2. 值传递的方式给函数参数传值
3. 值方式返回局部对象

##### 4.2.3 构造函数的调用规则

C++编译器至少会给一个类添加3个函数
1. 默认构造函数，函数体为空
2. 默认析构函数，函数体为空
1. 默认拷贝构造函数，对属性值进行拷贝

构造函数的调用规则:
1. 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造
2. 如果用户定义拷贝构造函数，C++不会在提供其他构造函数


##### 4.2.4 深拷贝和浅拷贝

* 浅拷贝: 生成的对象指向同一块地址，简单的赋值拷贝
* 深拷贝: 生成的对象将在堆区重新开辟一块内存，进行拷贝操作
如果属性有在堆区开辟的，一定要程序员自己提供拷贝构造函数，防止浅拷贝带来的问题(析构释放两次)


##### 4.2.5 初始化列表

初始化类为对象时，利用构造函数赋初值；
```
Person(int Age, int Height);
person(10, 130);
```
利用初始化列表赋初值
```
Person(int Age=0, int Height=0): Age(a), Height(b)
person(10, 130);
```


##### 4.2.6 类对象作为类成员


```
// 创建类
class Phone
{
public:
    int Year;
    string Pho;
};

// 人类
class Person
{
public:
    Phone m_phone; // 类成员
}
```

当创建对象Person时，类成员为Phone：
先调用Phone 有参构造函数， 再调用Person 有参构造函数
先调用Person 析构函数， 后调用Phone 析构函数


##### 4.2.7 静态成员

静态成员就是在类成员变量和成员函数加上关键字static，成为静态成员。分为
* 静态成员
    - 不属于某个对象，所有对象共享一份数据
    - 编译阶段分配共享内存
    - *类内声明，类外初始化*
* 静态成员函数
    - 所有对象共享同一个函数
    - 静态成员函数只能访问静态成员变量



#### 4.3 C++对象模型和this指针


##### 4.3.1 成员变量和成员函数分开存储, 只有非静态成员变量才属于类的对象


##### 4.3.2 this指针(类似python中self)

* 1. 解决名称冲突
* 2. 


##### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是要注意有没有用到this指针

如果用到this指针, 需要加以判断保证代码的健壮性


##### 4.3.4 const修饰成员函数

* 常函数
    - 在成员函数后面加上 const
    - 常函数内不可以修改成员属性
    - 成员属性声明是加关键字mutable后，在常函数中仍然可以修改
* 常对象
    - 声明对象前加const
    - 常对象只能调用常函数

#### 4.4 友元

##### 4.4.1 全局函数做友元

##### 4.4.2 类做友元

##### 4.4.3 成员函数做友元


#### 4.5 运算符重载

对自定义数据进行运算符操作；比如对类

##### 4.5.1 通过成员函数、全局函数重载

##### 4.5.2 左移运算符重载

##### 4.5.3 递增运算符重载

##### 4.5.4 赋值运算符重载

##### 4.5.5 关系运算符重载
重载关系运算符，可以让两个自定义类型数进行对比操作

##### 4.5.6 函数调用运算符重载
* 函数运算符()也可以重载
* 由于重载后的使用方式非常像函数的调用，因此称为仿函数
* 反函数没有固定写法，非常灵活


#### 4.6 类的继承

*可以减少大量重复代码的使用*

##### 4.6.1 语法

语法: `class child: 继承方式 parent

    - 子类 派生类

    - 父类 基类


##### 4.6.2 继承方式

* 公共继承
* 保护继承
* 私有继承

[继承属性变化参考](../part2/part4_class/inherit/inherit_mode.cpp)


##### 4.6.3 [继承中的构造顺序和析构顺序](../part2/part4_class/inherit/order_of_construction_destruction_in_inheritance.cpp)

子类继承父类构造顺序和析构顺序:

调用父类Parent构造函数 -> 调用子类Son1构造函数 -> 调用子类Son1析构函数 -> 调用父类Parent析构函


##### 4.6.4 [继承中的同名成员处理](../part2/part4_class/inherit/handling_same_name_member_in_inheritance.cpp)

* 通过子类对象访问父类中同名成员， 需要加作用域
* 通过子类对象访问父类中同名成员函数， 也需要加作用域

当静态成员和非静态成员出现同名，处理方式一致:
* 访问子类同名静态成员， 直接访问就行
* 访问父类同名静态成员， 需要加作用域

##### 4.6.5 [多继承](../part2/part4_class/inherit/multi_inheritance.cpp)

语法: `class 子类: public 父类1, public 父类2`

构造和析构顺序： 调用父类Parent1构造函数 -> 调用父类Parent2构造函数 -> 调用子类Son1构造函数 
                -> 调用子类Son1析构函数 -> 调用父类Parent2析构函数 -> 调用父类Parent1析构函数


##### 4.6.6 [菱形继承](../part2/part4_class/inherit/diamond_inheritance.cpp)

子类继承了两份相同的数据，导致资源浪费和毫无意义
需要加*虚拟继承*解决上述问题


##### 4.7 类的三大特性--多态

##### 4.7.1 [多态的基本概念](../part2/part4_class/polymorphism/demo.cpp)

多态分为两类:

* 静态多态: 函数重载和运算符重载属于静态多态，复用函数名
* 动态多态: 派生类和虚函数实现运行时多态

静态多态和动态多态的区别:
* 静态多态的函数地址早绑定 - 编译器阶段确定函数地址
* 动态多态的函数地址晚绑定 - 运行阶段确定函数地址


多态满足条件:
* 1. 有继承关系
* 2. 子类*重写*父类虚函数
*重写*: 函数返回类型 函数名 参数列表完全一致成为重写


多态使用:
* 父类指针或引用 指向子类对象

##### 4.7.2 [多态案例--计算器](../part2/part4_class/polymorphism/example_calculator.cpp)

利用普通方法和多态实现多态


##### 4.7.3 [纯虚函数](../part2/part4_class/polymorphism/pure_virtual.cpp)

虚函数语法: `vitual 返回值类型 函数名 (参数列表) = 0;`
此时对应的类也称之为*抽象类*， 其特点:
* 无法实例化对象
* 子类必须重写抽象类中的虚函数，否则也是抽象类


##### 4.7.4 [虚析构函数和纯虚析构函数](../part2/part4_class/polymorphism/pure_destructor.cpp)

多态使用时，如果*子类有在堆区创建的数据*，那么父类指针在释放时无法调用子类的析构函数，导致内存泄露

*解决方式*： 将父类中的析构函数改为*虚析构*或者*纯虚析构*
* 共性: 两者都需要具体的函数实现；
* 异性: 如果是纯虚析构，该类属于抽象类，无法实例化对象；

虚析构语法: `vitual ~类名(){}`

纯虚析构语法, 需要声明和实现: `vitual ~类名() = 0;`, `类名::类名(){}`



##### 4.7.5 [多态示例--电脑组装](../part2/part4_class/polymorphism/computer.cpp)
类总结--多态示例: 类，实例化，继承，构造，析构，多态



### 5. 文件操作

程序运行是产生的数据都属于临时数据，程序运行结束时都会被释放

通过文件可以将数据持久化

C++中对文件操作需要包含头文件<fstream>


文件类型分为两种:
* 1. 文本文件 - 文件以文本的ASCII码存储在计算机中
* 2. 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂


操作文件的三大类:
* 1. ofstream 写操作
* 2. ifstream 读操作
* 3. fstream 读写操作

文件打开方式:
|    打开方式     |    解释    |
|----------------|-----------|
|    ios::in     |  为读文件而打开文件 |
|    ios::out    |  为写文件而打开文件 |
|    ios::ate    |  初识位置: 文件尾  |
|    ios::app    |  追加方式写文件    |
|    ios::trunc  |  如果文件存在先删除，在创建 |
|    ios::binary |  二进制方式 |

注意: 文件打开方式可以配合使用，利用`|`操作符，例如`ios::in | ios::out`

#### 5.1 [文本文件](../part2/part5/read_write/read_write.cpp)

写入:
* 包含头文件 `include<fstream>`
* 创建流对象 `ofstream ofs;`
* 指定路径和打开方式 `ofs.open(path.txt, ios::out);`
* 写入内容   `ofs << "hello" << endl;`
* 关闭文件   `ofs.close();`

读取:
* 包含头文件 `include<fstream>`
* 创建流对象 `ifstream ifs;`
* 指定路径和打开方式 `ifs.open(path.txt, ios::in);`
* 判断是否正常打开 
    ```
    if ( ! ifs.is_open()){
        cout << "read file failed !" << endl;
        return;
    }``` 
* 读取内容的三种方式   
    ```
    char buf[1024];
    // 按行读取
    while ( ifs.getline(buf, sizeof(buf)) ){
        cout << buf << endl;
    }
    ```
* 关闭文件   `ifs.close();`

#### 5.1 [二进制文件](../part2/part5/read_write/read_write_byte.cpp)

写入: 调用成员函数write, `ostream& write(const char *buf, int len);`, 其中， 字符指针buf指向内存中的一段空间，len是读写的字节
* 包含头文件 `include<fstream>`
* 创建流对象 `ofstream ofs;`
* 指定路径和打开方式 `ofs.open(path.txt, ios::out | ios::binary);`
* 写入内容   
    ```
        Person p2;
        ifs.read((char *)&p2, sizeof(Person));  // read() 方法从文件中读取 Person 对象的数据，并将其赋值给 p2
        cout << "Name: " << p2.Name << "\t Age: " << p2.Age << endl;

        string test;
        ifs.read((char *)&test, sizeof(test)); 
    ```
* 关闭文件   `ofs.close();`

读取: 调用成员函数read, `ostream& read(const char *buf, int len);`, 其中， 字符指针buf指向内存中的一段空间，len是读写的字节
* 包含头文件 `include<fstream>`
* 创建流对象 `ifstream ifs;`
* 指定路径和打开方式 `ifs.open(path.txt, ios::in | ios::binary);`
* 判断是否正常打开 
* 读取内容   
    ```
        Person p2;
        ifs.read((char *)&p2, sizeof(Person));  // read() 方法从文件中读取 Person 对象的数据，并将其赋值给 p2
        cout << "Name: " << p2.Name << "\t Age: " << p2.Age << endl;

        string test;
        ifs.read((char *)&test, sizeof(test));  // 使用 read() 方法从文件中读取字符串数据，并将其赋值给 test
        cout << test << endl;
    ```
* 关闭文件   `ifs.close();`



*本章节难点:*

* 1. 指针和引用
* 2. 运算符重载