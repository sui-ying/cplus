## 核心编程

### 1. 内存分区模型

C++程序在执行时，将内存大方向分为4个区域:

* 代码区:存放函数的二进制代码，由操作系统进行管理的

* 全局区:存放全局变量、静态变量和常量

* 栈区:由编译器自动分配释放，存放函数的参数值，全局变量等

* 堆区:由程序员分配new和释放delete，若不释放，程序结束时有操作系统回收；由关键字new创建

内存分区意义: 不同区域存放的数量，赋予不同的生命周期，更加灵活地编程


#### 1.1 程序运行前

代码区:

* 存放CPU执行的机器指令
* 代码区是共享的，共享的母的是杜宇频繁被执行的程序，只需要在内存中有一封代码即可
* 代码区是只读的，使其只读的原因是防止程序意外的修改它的指令

全局区:

* 全局变量和惊天变量存放在此
* 全局区还包含了常量区，字符串常量和其他常量
* 该区域的数据在程序执行后由操作系统释放


#### 1.2 程序运行后

栈区:
* 栈区的数据有编译器管理和开辟、释放
* 不要返回局部变量的地址


### 2. 引用

* 作用: 给变量起别名
* 引用必须初始化，之后不可以改变


### 3. 函数进阶

* 函数默认参数
* 函数重载


### 4. 类和对象

C++面向对象的三大特性为: *封装*、*继承*、*多态*
    encapsulation inherits polymorphism

对象有其属性和行为

#### 4.1 封装

##### 4.1.1 封装的意义

* 将属性和行为作为一个整体，表现生活中的事务
* 将属性和行为加以权限控制

1. 在设计类的时候，将属性和行为写在一起，表现事物

语法: `class classname {};`

2. 访问权限

*公共权限 pubic       成员 类内可以访问，类外也可以访问
*保护权限 protected   成员 类内可以访问，类外不可以访问
*私有权限 private     成员 类内可以访问，类外不可以访问

保护权限和私有权限，在类的继承时有所不同

一般做法: 将成员属性设置为私有，对于写可以检测数据的有效性


#### 4.2 对象的初始化和清理 

##### 4.2.1 *构造函数和析构函数*

对象的初始化和清理是非常重要的安全问题:
* 一个对象或者变量没有初识状态，对其使用后果是未知的
* 同样的使用完一个对象或者变量 没有及时清理，也会造成一定的安全问题

C++通过使用构造函数和析构函数解决上述问题，将这两个函数会被编译器自动调用，完成对象初始化和清理工作
如果编写代码中不提供构造和析构，编译器会提供
编译器提供的构造韩函数析构函数是空实现的

*构造函数*: 主要作用于创建对象时为对象的成员属性赋值，构造函数有编译器自动调用，无须手动调用
*析构函数*: 主要作用于对象销毁前系统自动调用，执行一些清理工作

[构造函数]语法: `类名(){}`
1. 构造函数没有返回值也不写void
2. 函数名称与，类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次

[析构函数]语法: `~类名(){}`
1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数*不可以有参数*，因此不可以重载
4. 程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次


##### 4.2.2 *构造函数和析构函数*的分类和调用

两种分类方式:
* 按参数分为: 有参构造和无惨构造
* 按类型分为: 普通构造和拷贝构造

三种调用方式:
1. 括号法
2. 显示法
3. 隐式转换法

拷贝构造函数的使用时机:
1. 使用一个已经创建完毕的对象 来初始化
2. 值传递的方式给函数参数传值
3. 值方式返回局部对象

##### 4.2.3 构造函数的调用规则

C++编译器至少会给一个类添加3个函数
1. 默认构造函数，函数体为空
2. 默认析构函数，函数体为空
1. 默认拷贝构造函数，对属性值进行拷贝

构造函数的调用规则:
1. 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造
2. 如果用户定义拷贝构造函数，C++不会在提供其他构造函数


##### 4.2.4 深拷贝和浅拷贝

* 浅拷贝: 生成的对象指向同一块地址，简单的赋值拷贝
* 深拷贝: 生成的对象将在堆区重新开辟一块内存，进行拷贝操作
如果属性有在堆区开辟的，一定要程序员自己提供拷贝构造函数，防止浅拷贝带来的问题(析构释放两次)


##### 4.2.5 初始化列表

初始化类为对象时，利用构造函数赋初值；
```
Person(int Age; int Height);
person(10, 130);
```
利用初始化列表赋初值
```
Person(int Age; int Height): Age(a), Height(b)
person(10, 130);
```


##### 4.2.6 类对象作为类成员


```
// 创建类
class Phone
{
public:
    int Year;
    string Pho;
};

// 人类
class Person
{
public:
    Phone m_phone; // 类成员
}
```

当创建对象Person时，类成员为Phone：
先调用Phone 有参构造函数， 再调用Person 有参构造函数
先调用Person 析构函数， 后调用Phone 析构函数


##### 4.2.7 静态成员

静态成员就是在类成员变量和成员函数加上关键字static，成为静态成员。分为
* 静态成员
    - 不属于某个对象，所有对象共享一份数据
    - 编译阶段分配共享内存
    - 类内声明，类外初始化
* 静态成员函数
    - 所有对象共享同一个函数
    - 静态成员函数只能访问静态成员变量



#### 4.3 C++对象模型和this指针

##### 4.3.1 成员变量和成员函数分开存储, 只有非静态成员变量才属于类的对象

##### 4.3.2 this指针

* 1. 解决名称冲突
* 2. 